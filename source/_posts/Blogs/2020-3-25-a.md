---
title: C++ 中通过构造虚函数表的方式在父类中调用子类重写的虚函数
date: 2020-3-25
layout: post
tag: C/C++
---

## 问题的起源

在 zhihu 首页看到一个提问：如何在父类中调用子类的虚函数？

看到这个问题，会感到一丝丝疑惑：这难道不是 C++ 本身的特性吗？没错，虚函数就是为此而生的。

比如看下面的代码：

```c++
class Base
{
public:
  virtual void func();
  void call_child_func();
}
class Child : public Base
{
public:
  void func() override;
}

Base::call_child_func()
{
  func();
}

Base* instance = new Child;
instance->call_child_func();
```

这样的调用基本上没什么意义，因为根据虚函数的性质，instance 会按照其本来的类型去调用对应的虚函数，而不是按照表面上表现出来的类型，所以直接用 instance->func() 就可以满足需求。

## 进一步探究

zhihu 上该问题下有一个答案引起了我的兴趣，答主给出了一种通过在子类中构造虚函数表的方式来实现父类调用子类重写的虚函数的方式，虽然其作用和上述方案是一样的，但是构造出的虚函数表结构却很有意思，具体的方法见如下分析：

首先是要用到的头文件和命名空间：

```c++
#include <iostream>
#include <functional>
using namespace std;
```

假设现在定义了一个基类为 Monster，这个 Monster 有一个攻击的行为，对应于虚函数 Attack：

```c++
class Monster
{
public:
  virtual void Attack()
  {   
    cout << "Monster Attack!" << endl;
  }   

  void InvokeChildAttack()
  {   
    // TODO
  }     
};
```

现在的需求是，如何确保当调用 InvokeChildAttack 方法时，调用的是继承了 Monster 的子类中重写的虚函数 Attack，而不是 Monster 中的 Attack。

比如，现在实现一个 Goblin 类继承 Monster，并重写 Attack：

```c++
class Goblin : public Monster
{
public:
  void Attack() override
  {
    cout << "Goblin's stick attack!" << endl;
  }
};

```

接下来是重点，如何在 Monster 中去调用 Goblin 的 Attack 呢？为了使用构造出的虚函数表（等下就会看到），还需在 Monster 中添加几个函数指针成员：

```c++
class Monster
{
public:
  // 省略代码

  void InvokeChildAttack()
  {   
    (this->*m_childAttack)();
  }

  void InvokeChildAttack_cpp11()
  {   
    this->m_childAttack_cpp11();
  }

  void(Monster::*m_childAttack)();
  function<void()> m_childAttack_cpp11;
};
```

m_childAttack 和 m_childAttack_cpp11 将会在子类中被赋值为对应的子类重写的虚函数 Attack，因为这些函数指针变量是在 Monster 中声明的，故在 Monster 中可直接调用它们，这样就达到了在运行时去调用子类的虚函数的目的：

```c++
class Goblin : public Monster
{
public:
  Goblin()
  {   
    struct VirtualFuncTable
    {   
      union
      {   
        void(Goblin::*goblinAttack)();
        void(Monster::*monsterAttack)();
      };
    } m_virtualFuncTable = { &Goblin::Attack };
    // 通用方法
    this->m_childAttack = m_virtualFuncTable.monsterAttack;
    // C++11 中的新方法
    this->m_childAttack_cpp11 = bind(&Goblin::Attack, this);
  }

  // 省略代码
};
```

如上，在子类 Goblin 的构造函数中，构造了一个虚函数表结构：

```c++
struct VirtualFuncTable
{   
  union
  {   
    void(Goblin::*goblinAttack)();
    void(Monster::*monsterAttack)();
  };
};
```

其实就是：

```c++
struct vbtl
{
  union
  {
    void(Child_N::*func_N)(); // 继承树中的第 N 代子类
    // 省略很多代子类
    void(Child_2::*func_2)(); // 第二代子类
    void(Child_1::*func_1)(); // 第一代子类
    void(Parent::*func)(); // 基类
  };
};
```

在虚函数表中，最底层的子类放置在第一个位置，以此类推，最初的父类放置在最后，因为在调用虚函数时，会首先在虚函数表中查找是否有当前类对应的虚函数，如果没有，就尝试查找父类的，如果还没有，就继续查找父类的父类，直到找到第一个重写的虚函数为止，因此会有如上特定的排列顺序。在构造虚函数表时要注意这个顺序不能改变，因为在 C++ 中结构的赋值是一个一个对齐进行的。

```c++
m_virtualFuncTable = { &Goblin::Attack };
```

通过这个赋值可以看出，在 C++ 中虚函数和普通的函数不同，声明为 virtual 的函数不再是简单对应一个函数指针，而是对应到一个 union 结构，也就是虚函数表，根据实际类型的不同，这个 union 所对应的函数也不同，这样就实现了虚函数的多态性。

最后执行如下语句：

```c++
int main()
{
  Monster *goblin = new Goblin;
  goblin->Attack();
  goblin->InvokeChildAttack();
  goblin->InvokeChildAttack_cpp11();
}
```

输出为：

```
Goblin's stick attack!
Goblin's stick attack!
Goblin's stick attack!
```

可见，InvokeChildAttack 达到了和单纯的虚函数 Attack 一样的效果。

## 总结

总结来说，这其实映射出 C++ 中虚函数多态的本质，也就是虚函数表的动态性，虽然实际应用中可能价值不大（其实 zhihu 答主给出了一些实际的应用），但是研究一番却很有意思。