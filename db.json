{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/yiyaowen.jpg","path":"avatar/yiyaowen.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.gif","path":"assets/favicon.gif","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/images/PirateBombSE_Introduction/Main_Menu.jpg","path":"assets/images/PirateBombSE_Introduction/Main_Menu.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1616586833933},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1616586960727},{"_id":"themes/archer/.eslintrc.json","hash":"35eeca97fa5a2d0c6d78ef1257c58f03c42d43df","modified":1616586960721},{"_id":"themes/archer/.gitignore","hash":"3c75d7681ccc4edd053107bee5a8c58607fb036d","modified":1616586960722},{"_id":"themes/archer/.prettierignore","hash":"58caf761f07e5df9cdc21f7f19f0670fde41089b","modified":1616586960722},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1616586960721},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1616586960722},{"_id":"themes/archer/.prettierrc.js","hash":"875b0b95f6eb24a23e4ea83a75709b97897135e0","modified":1616586960722},{"_id":"themes/archer/README.md","hash":"a3ba929435da6adbed7b03657f84b69ab37cfe33","modified":1616586960722},{"_id":"themes/archer/_config.yml","hash":"ce565e5ab3019dc0f3f4e43f307e9dca7317ae91","modified":1616676935371},{"_id":"themes/archer/gulpfile.js","hash":"46dfe693b00ac4dea4d1b1af56f5ced4ee095c10","modified":1616586960725},{"_id":"themes/archer/package.json","hash":"531fe40833ca63493f62adfa249b6434310a2d0a","modified":1616586960734},{"_id":"themes/archer/webpack.config.js","hash":"d20b6350c50e2981484cb9356a3e21a2124bcd72","modified":1616586960759},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1616586960723},{"_id":"themes/archer/webpack.prod.js","hash":"48de76cfa6274895801d3afc89ecbf04ee182a1c","modified":1616586960759},{"_id":"themes/archer/docs/README-en.md","hash":"f325565c0bb94501fd046268659c7752709895d1","modified":1616586960723},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"0bb09c3c9d5f56820cb84e3316f60352b731d70c","modified":1616586960723},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"effc2bc9e0cecfd228b19283337ff29649ea5985","modified":1616586960723},{"_id":"themes/archer/languages/default.yml","hash":"d56b6923c70efdef09cd1f0270d7adc9cc338f6b","modified":1616586960725},{"_id":"themes/archer/languages/en.yml","hash":"ad75d3e5f7f5f0463d3077e1b5a26f40938a1faa","modified":1616586960725},{"_id":"themes/archer/layout/404.ejs","hash":"879641b1b5e49c43f2e096cad281f7d74df05127","modified":1616586960725},{"_id":"themes/archer/layout/about.ejs","hash":"06019d835c0a51fed8aa086d1dfcf368f9921b42","modified":1616586960730},{"_id":"themes/archer/layout/index.ejs","hash":"3194a741fdc93f93a299222d9cda9b99088639bc","modified":1616586960730},{"_id":"themes/archer/layout/layout.ejs","hash":"08ebd10c1b2bfc11be8f5115a836a98e6c6ba13c","modified":1616586960730},{"_id":"themes/archer/layout/post.ejs","hash":"9f886450a99eae3a8e1af78560ec6e72cefc36ca","modified":1616586960730},{"_id":"themes/archer/layout/site-meta.ejs","hash":"d866aa1a892d4bfe3368f6dbd0f1baa8c5831947","modified":1616586960731},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"012bd3afea5565204f75d8c89048ad33b9c2f948","modified":1616586960721},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"886fb1252702d46c89536b579d35ce49e53ec54d","modified":1616586960722},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"4bf3c8ebef14a81bb55e8e0468d816e83c4133ac","modified":1616586960722},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"2f5f9073378f628a9124792b5301c1540bc5a264","modified":1616586960725},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"82203d9a1c6e16ef2d37b8b587f56bf6d16edaf2","modified":1616586960726},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"7bfb8af21f7d30780d1a3af5484760b07b4fbb1d","modified":1616586960726},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"5e6276242a8bd3f76b35d93393c95e58b7884840","modified":1616586960726},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"12e28693dc53cab5f6fd389f15ea0f811c9c37e9","modified":1616586960726},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"2aea84cb43f4479131620b3c3dfd7cebe9be36ba","modified":1616586960726},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"743d97452d4ac358e631c43c9c2120aafdfd3e24","modified":1616586960726},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"2d068432031b3bebf9438c775370a2d1b4492d6b","modified":1616586960726},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"418559ab11726f69621c3a58cd21903adff1e48e","modified":1616586960726},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"cd0d34a811dc4666980d57c00d70dd82bd5450eb","modified":1616586960728},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1616586960735},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1616586960735},{"_id":"themes/archer/source/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1616586960735},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1616586960736},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1616586960736},{"_id":"themes/archer/source/css/style.css","hash":"8e41748502e35784a242c3f11d758fece302f77c","modified":1616586960737},{"_id":"themes/archer/source/css/mobile.css","hash":"51d7b5cf26c8f82a3daad4bc55518673fdf281f5","modified":1616586960737},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1616586960738},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1616586960739},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1616586960749},{"_id":"themes/archer/source/scripts/search.js","hash":"127c388b575c2cb0a850b32c08dd61d6a6f690ba","modified":1616586960750},{"_id":"themes/archer/source/scripts/share.js","hash":"419c5e6e202fc899411d36e24cf453b48af8aef7","modified":1616586960750},{"_id":"themes/archer/src/js/browser.js","hash":"ce061db99db5b880db0ddb768246352ca885b13c","modified":1616586960751},{"_id":"themes/archer/src/js/fancybox.js","hash":"0daf0e83deca055102268e3bd95cb1962acc2264","modified":1616586960751},{"_id":"themes/archer/src/js/init.js","hash":"346c6ef75ae85e4350c1b0811985172fdaa0d3a5","modified":1616586960751},{"_id":"themes/archer/src/js/initSidebar.js","hash":"b25615ff254913db83e2a20263d445f35083843b","modified":1616586960752},{"_id":"themes/archer/src/js/main.js","hash":"e1a48d5822326792e38d44efee86e01473549eba","modified":1616586960752},{"_id":"themes/archer/src/js/mobile.js","hash":"228a68d851517b5e47d2132f1d499cb812a64171","modified":1616586960752},{"_id":"themes/archer/src/js/scroll.js","hash":"aa2315a80daaa183a7e462c7e879ff9d2f050933","modified":1616586960753},{"_id":"themes/archer/src/js/share.js","hash":"1314b19a852e291e35d6809f7f58652d3e7c524c","modified":1616586960753},{"_id":"themes/archer/src/js/sidebar.js","hash":"0900c4a368687f882ba0559419b23357c534c403","modified":1616586960753},{"_id":"themes/archer/src/js/search.js","hash":"2e59ac745da7c22801d9029cf9904a4fc3c384f1","modified":1616586960753},{"_id":"themes/archer/src/js/toc.js","hash":"b3482031e4c8728535d480bfaec76229469e3aba","modified":1616586960754},{"_id":"themes/archer/src/js/tag.js","hash":"4916f913c28943f857a0fcfdd191e24628f9193b","modified":1616586960754},{"_id":"themes/archer/src/js/util.js","hash":"27de6446892bcf399430dd5776df0b8759ca0eea","modified":1616586960754},{"_id":"themes/archer/src/scss/_common.scss","hash":"dedc313b082e0a16daf87213badd21b13be11af8","modified":1616586960754},{"_id":"themes/archer/src/scss/_variables.scss","hash":"ae02688ca43de060d7b0103994b980262dfbb13d","modified":1616587651791},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"e7deb20a16868ae9d3e35ba3c5693de71fdf6999","modified":1616586960755},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1616586960755},{"_id":"themes/archer/src/scss/mobile.scss","hash":"aadc2fbf37fefc2ad391d8172d5b61817f9db0c5","modified":1616586960759},{"_id":"themes/archer/src/scss/style.scss","hash":"78e31370d45089b97fa91929345f1a29f2e6a0a2","modified":1616586960759},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"7691642fb9375607e0ac988a7420999e242cb2c9","modified":1616586960727},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cadd97820a23d01d8b7e2f19a86e5290cef5a8a6","modified":1616586960727},{"_id":"themes/archer/layout/_partial/comment/gitalk.ejs","hash":"809196ba5e91d4ba00477dd3e9768bd384dc9c9a","modified":1616586960727},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"031401489f3487b13fafcb17eea7c877f2f3b98f","modified":1616586960727},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"b27469f19f35ec2037c7bce736a12e9dfb5e360b","modified":1616586960727},{"_id":"themes/archer/layout/_partial/comment/utteranc.ejs","hash":"cc41ba5da413cf39b809e7defb360b0d8fafc6f3","modified":1616586960727},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"2154360e330dab94540e168e9d301c7b7091968e","modified":1616586960728},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"790d76f2667377db78a7d04bad8d629e47e7aab0","modified":1616586960728},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"c03e16a7741908c207bf58363dcd1349cb639ef8","modified":1616586960728},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"291cc0a4a444a93b93c32e2c39383c70e36e46de","modified":1616586960729},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"2d38af7cb5aabc0af99de239bd180c516ec4c56c","modified":1616586960729},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"daa78b17a773bca569f1c8ca2c916495ca138da6","modified":1616586960729},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"d6e1a192cac5dcf365ce1a52df4f23feafeeb849","modified":1616586960729},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"147214469c4909eb94943599883f9fa0f3cc090d","modified":1616586960729},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"a2b56f441a9a44d7f5b9b41eaa8136321328d7e9","modified":1616586960755},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"c679578d2feb0bd7d3f80c2f693ba58cbca4428b","modified":1616586960755},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"fa993cf0bbe0086cd8ec3d9a639b2d5b28ccfa8e","modified":1616586960756},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7c557844850d53cc4fc36aaf6d59847d8f238947","modified":1616586960757},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"726c543ee066e0b3222b236d9b4ef0109c0bdddf","modified":1616586960756},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"412b17cfac52e12751d248a704e5eb139e937bc4","modified":1616586960756},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"a1569f39eccd64a12425d81b794c53df126a4d87","modified":1616586960756},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"f2514031f9d7e4ed4a126694e78618ce6ff3a574","modified":1616586960757},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"0c986b52ce9083f08c37c5c9b5de045ac5e1d2fa","modified":1616586960757},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1616586960757},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"14bc42292873880c61b5fa9f47ee9d2e08d46871","modified":1616586960758},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"9c9a4e470da8732c9a3be3d5ce0d2f80f53714fe","modified":1616586960758},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"93cc82cb56663e83e90fbd6fe31ffdd38e694f3b","modified":1616586960758},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"981a94978535769cb51c29e12b627f83c6fcedc5","modified":1616586960758},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1616586960738},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1616586960740},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"99a1c725a5671ea6c8f27136678c8048cc3abed4","modified":1616591992525},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1616586960740},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1616586960748},{"_id":"themes/archer/source/scripts/main.js","hash":"2cfe993eb1579e8aebf73b00d699b25be07981fa","modified":1616586960750},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"c929d38aa06b63f3e2b04951c4d24aeada5a862b","modified":1616591893150},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"856bb6f98e28b8b84c3f6dc9272aaa106eacafcd","modified":1616593479517},{"_id":"themes/archer/package-lock.json","hash":"89a3b67d32f6916cdc21d590d87e43d8a44be8c3","modified":1616586960733},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1616586960725},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"dad8f824f8134bc53294878d6d25e08c4a149c9b","modified":1616591451976},{"_id":"source/about/index.md","hash":"ee8d7f26b9627236e7157c2be201f4e139a74050","modified":1616597570708},{"_id":"source/404.md","hash":"6ae3f11c2fe790b7efb888cfd7b456e4644ab419","modified":1616587445923},{"_id":"themes/archer/source/intro/index-bg2.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1616586960745},{"_id":"themes/archer/source/intro/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1616588985725},{"_id":"themes/archer/source/avatar/yiyaowen.jpg","hash":"f622fda8c87925a062cf0ce6ec455675a8b0c9f5","modified":1616589849703},{"_id":"themes/archer/source/avatar/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1616589897867},{"_id":"themes/archer/source/assets/favicon.jpg","hash":"f622fda8c87925a062cf0ce6ec455675a8b0c9f5","modified":1616589849703},{"_id":"themes/archer/source/assets/.DS_Store","hash":"49ee1a2bc85bf3ab7a83e73ece5d94c8f4ec2078","modified":1616672553492},{"_id":"themes/archer/source/assets/wechat.jpg","hash":"9b3a337c0661d6f056e7d453c89d4e483bf415b4","modified":1616590099321},{"_id":"themes/archer/source/assets/qq.jpg","hash":"6e43242f4c6cff5d202859b30fb771364ccf7772","modified":1616590098626},{"_id":"themes/archer/source/assets/favicon.gif","hash":"94b01fd6d3f0d2a22fb423ff941e894f8d03bc6f","modified":1616590976714},{"_id":"source/_posts/.DS_Store","hash":"1c3fda6d169b4e22e4bff10cf37d7097bfa994e3","modified":1616674322724},{"_id":"source/_posts/hello.md","hash":"52d7f710a975478bb80ebcc1d8d70d3b33fe31c3","modified":1616596817188},{"_id":"source/_posts/PirateBombSE_Introduction.md","hash":"cc10eb6fd1133fa1bb59e7bb83359df7c3ff0dac","modified":1616672645900},{"_id":"source/.DS_Store","hash":"61ef0bc1dde8f8224d5576133fa3caf8e89fd007","modified":1616597659903},{"_id":"themes/archer/source/.DS_Store","hash":"b6f6bb58d2481725201f9c16f5658536a52f721d","modified":1616597659901},{"_id":"themes/archer/src/.DS_Store","hash":"de2d3a9fe7c608693ab90aecf268263d1ff81bd6","modified":1616597659894},{"_id":"public/content.json","hash":"0f6655c108805d5f9a62ae94afe4c5b2aced31dc","modified":1616677224896},{"_id":"public/about/index.html","hash":"639e5207c16ccc16960c73369249074a160559a2","modified":1616677224896},{"_id":"public/404.html","hash":"202b575833f10691b66831439d89bdadfe459b58","modified":1616677224896},{"_id":"public/9999/09/09/PirateBombSE_Introduction/index.html","hash":"b017110e6d0ed2453ecb8da4ef8315adb855e1e5","modified":1616598437156},{"_id":"public/archives/index.html","hash":"9540b26a00ae8cdae7613f345ecd2349614b351b","modified":1616677224896},{"_id":"public/archives/9999/index.html","hash":"9f49fab0d27dd2d4d5f3fb57f44e89f2c73b5798","modified":1616677224896},{"_id":"public/archives/9999/09/index.html","hash":"10d9286c9c77810a1ca20a6f0a277395019ba3aa","modified":1616677224896},{"_id":"public/index.html","hash":"52c812ad7c668a3f9785d2d10fea32a39afe966f","modified":1616677224896},{"_id":"public/tags/游戏/index.html","hash":"717694e1e46d3f64d8d6927d4f11030f797bb107","modified":1616677224896},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1616598437156},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1616598437156},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1616598437156},{"_id":"public/avatar/yiyaowen.jpg","hash":"f622fda8c87925a062cf0ce6ec455675a8b0c9f5","modified":1616598437156},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1616598437156},{"_id":"public/intro/404-bg.jpg","hash":"99a1c725a5671ea6c8f27136678c8048cc3abed4","modified":1616598437156},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1616598437156},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1616598437156},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1616598437156},{"_id":"public/assets/favicon.gif","hash":"94b01fd6d3f0d2a22fb423ff941e894f8d03bc6f","modified":1616598437156},{"_id":"public/intro/about-bg.jpg","hash":"c929d38aa06b63f3e2b04951c4d24aeada5a862b","modified":1616598437156},{"_id":"public/css/mobile.css","hash":"51d7b5cf26c8f82a3daad4bc55518673fdf281f5","modified":1616598437156},{"_id":"public/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1616598437156},{"_id":"public/scripts/search.js","hash":"127c388b575c2cb0a850b32c08dd61d6a6f690ba","modified":1616598437156},{"_id":"public/css/style.css","hash":"8e41748502e35784a242c3f11d758fece302f77c","modified":1616598437156},{"_id":"public/scripts/share.js","hash":"419c5e6e202fc899411d36e24cf453b48af8aef7","modified":1616598437156},{"_id":"public/intro/post-bg.jpg","hash":"856bb6f98e28b8b84c3f6dc9272aaa106eacafcd","modified":1616598437156},{"_id":"public/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1616598437156},{"_id":"public/scripts/main.js","hash":"2cfe993eb1579e8aebf73b00d699b25be07981fa","modified":1616598437156},{"_id":"public/intro/index-bg.jpg","hash":"dad8f824f8134bc53294878d6d25e08c4a149c9b","modified":1616598437156},{"_id":"themes/archer/._config.yml.swp","hash":"9c9d4108f65f9dc61c91cc7be881ee3f37c09055","modified":1616648728490},{"_id":"source/_posts/qt.jpg","hash":"7443a7edbfff0a00a2707c62b70b640897766d53","modified":1603182147181},{"_id":"themes/archer/source/assets/images/qt.jpg","hash":"7443a7edbfff0a00a2707c62b70b640897766d53","modified":1603182147181},{"_id":"source/_posts/Game_Introduction/PirateBombSE_Introduction.md","hash":"6e1311d8a21ddb08bad4cd412f6af5df0ef27cf6","modified":1616673126332},{"_id":"source/_posts/Games/PirateBombSE_Introduction.md","hash":"6e1311d8a21ddb08bad4cd412f6af5df0ef27cf6","modified":1616673126332},{"_id":"source/_posts/Games/Pirate_Bomb_SE.md","hash":"6e1311d8a21ddb08bad4cd412f6af5df0ef27cf6","modified":1616673126332},{"_id":"source/_posts/Blogs/2020-3-25-a.md","hash":"26b7146e93c48d110fa65d7f0c3389fd4ecaa606","modified":1616677199685},{"_id":"themes/archer/source/assets/images/.DS_Store","hash":"f7c36f9aa9a191b968a73bd56b5a36cdcd44922d","modified":1616672753633},{"_id":"themes/archer/source/assets/images/PirateBombSE_Introduction/.DS_Store","hash":"ffb540b2443af0e23cca12f9964063405f5576db","modified":1616672755879},{"_id":"themes/archer/source/assets/images/PirateBombSE_Introduction/Main_Menu.jpg","hash":"dad8f824f8134bc53294878d6d25e08c4a149c9b","modified":1616648246124},{"_id":"public/9999/09/09/Games/Pirate_Bomb_SE/index.html","hash":"d0b0aca4b50810d43e698aed24d0090b82ad552f","modified":1616677224896},{"_id":"public/2020/03/25/Blogs/2020-3-25-a/index.html","hash":"27bf19258150596257a6faa5363dd44036c1ee78","modified":1616677224896},{"_id":"public/archives/2020/index.html","hash":"3a200cd4d9769d3a8013d5d83158a8a08c342749","modified":1616677224896},{"_id":"public/archives/2020/03/index.html","hash":"3d9a13dccd47d6ce0dc9aef3db81a3061e997d05","modified":1616677224896},{"_id":"public/tags/C-C/index.html","hash":"bac588391ca8ad99372181fe77e38f74f6cef27c","modified":1616677224896},{"_id":"public/assets/images/PirateBombSE_Introduction/Main_Menu.jpg","hash":"dad8f824f8134bc53294878d6d25e08c4a149c9b","modified":1616677224896}],"Category":[],"Data":[],"Page":[{"title":"yiyaowen","layout":"about","_content":"\n### 独立游戏开发者、Gamer、电子人\n\nGitHub 主页：https://github.com/yiyaowen","source":"about/index.md","raw":"---\ntitle: yiyaowen\nlayout: about\n---\n\n### 独立游戏开发者、Gamer、电子人\n\nGitHub 主页：https://github.com/yiyaowen","date":"2021-03-24T14:52:50.716Z","updated":"2021-03-24T14:52:50.708Z","path":"about/index.html","_id":"ckmneb8w00000s89khn0ae8ai","comments":1,"content":"<h3 id=\"独立游戏开发者、Gamer、电子人\"><a href=\"#独立游戏开发者、Gamer、电子人\" class=\"headerlink\" title=\"独立游戏开发者、Gamer、电子人\"></a>独立游戏开发者、Gamer、电子人</h3><p>GitHub 主页：<a href=\"https://github.com/yiyaowen\">https://github.com/yiyaowen</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"独立游戏开发者、Gamer、电子人\"><a href=\"#独立游戏开发者、Gamer、电子人\" class=\"headerlink\" title=\"独立游戏开发者、Gamer、电子人\"></a>独立游戏开发者、Gamer、电子人</h3><p>GitHub 主页：<a href=\"https://github.com/yiyaowen\">https://github.com/yiyaowen</a></p>\n"},{"layout":"404","title":"[404]","description":"Page Not Found","_content":"","source":"404.md","raw":"---\nlayout: 404\ntitle: \"[404]\"\ndescription: \"Page Not Found\"\n---\n","date":"2021-03-24T12:04:05.948Z","updated":"2021-03-24T12:04:05.923Z","path":"404.html","comments":1,"_id":"ckmneh5s10000wv9k4dvhe4jo","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"新游戏：海盗炸弹特别版 / Pirate Bomb (Special Edition)","date":"9999-09-08T16:00:00.000Z","layout":"post","_content":"### 游戏下载\n\n下载地址：https://github.com/yiyaowen/PirateBomb_SE\n\n### 游戏简介\n\n***畏畏缩缩的船长，会吞炸弹的鲸鱼，还有足球队员光头哥、橄榄球教练水手弟……***\n\n***等等，这个像黄瓜一样的奇怪生物是什么？***\n\n![游戏主菜单](http://localhost:4000/assets/images/PirateBombSE_Introduction/Main_Menu.jpg)\n\n在“海盗炸弹特别版”里，玩家将扮演一个能够释放定时炸弹的小海盗，与来自未知地域的奇葩海盗团进行一系列“黑吃黑”的较量。在游戏中，玩家可以移动、跳跃来躲避敌人的攻击，另一方面也可以掐准时机释放炸弹来击败对手，不过偶尔也会有粗心的玩家被自己释放的炸弹击倒。看来，海盗也不是那么好当的呢，一次次地击败对手，进入更困难的关卡，不断地挑战自己的极限吧！\n\n### 关于游戏开发\n\n本游戏使用 Unity 引擎开发，所有美术素材均由 Pixel Frog 创作，只可用于学习和试玩等非商业性活动。\n\n开发者名单：\n\n制作人：yiyaowen","source":"_posts/Games/Pirate_Bomb_SE.md","raw":"---\ntitle: 新游戏：海盗炸弹特别版 / Pirate Bomb (Special Edition)\ndate: 9999-9-9\nlayout: post\ntags: 游戏\n---\n### 游戏下载\n\n下载地址：https://github.com/yiyaowen/PirateBomb_SE\n\n### 游戏简介\n\n***畏畏缩缩的船长，会吞炸弹的鲸鱼，还有足球队员光头哥、橄榄球教练水手弟……***\n\n***等等，这个像黄瓜一样的奇怪生物是什么？***\n\n![游戏主菜单](http://localhost:4000/assets/images/PirateBombSE_Introduction/Main_Menu.jpg)\n\n在“海盗炸弹特别版”里，玩家将扮演一个能够释放定时炸弹的小海盗，与来自未知地域的奇葩海盗团进行一系列“黑吃黑”的较量。在游戏中，玩家可以移动、跳跃来躲避敌人的攻击，另一方面也可以掐准时机释放炸弹来击败对手，不过偶尔也会有粗心的玩家被自己释放的炸弹击倒。看来，海盗也不是那么好当的呢，一次次地击败对手，进入更困难的关卡，不断地挑战自己的极限吧！\n\n### 关于游戏开发\n\n本游戏使用 Unity 引擎开发，所有美术素材均由 Pixel Frog 创作，只可用于学习和试玩等非商业性活动。\n\n开发者名单：\n\n制作人：yiyaowen","slug":"Games/Pirate_Bomb_SE","published":1,"updated":"2021-03-25T11:52:06.332Z","_id":"ckmotoivd0008r29k7i3w93be","comments":1,"photos":[],"link":"","content":"<h3 id=\"游戏下载\"><a href=\"#游戏下载\" class=\"headerlink\" title=\"游戏下载\"></a>游戏下载</h3><p>下载地址：<a href=\"https://github.com/yiyaowen/PirateBomb_SE\">https://github.com/yiyaowen/PirateBomb_SE</a></p>\n<h3 id=\"游戏简介\"><a href=\"#游戏简介\" class=\"headerlink\" title=\"游戏简介\"></a>游戏简介</h3><p><em><strong>畏畏缩缩的船长，会吞炸弹的鲸鱼，还有足球队员光头哥、橄榄球教练水手弟……</strong></em></p>\n<p><em><strong>等等，这个像黄瓜一样的奇怪生物是什么？</strong></em></p>\n<p><img src=\"http://localhost:4000/assets/images/PirateBombSE_Introduction/Main_Menu.jpg\" alt=\"游戏主菜单\"></p>\n<p>在“海盗炸弹特别版”里，玩家将扮演一个能够释放定时炸弹的小海盗，与来自未知地域的奇葩海盗团进行一系列“黑吃黑”的较量。在游戏中，玩家可以移动、跳跃来躲避敌人的攻击，另一方面也可以掐准时机释放炸弹来击败对手，不过偶尔也会有粗心的玩家被自己释放的炸弹击倒。看来，海盗也不是那么好当的呢，一次次地击败对手，进入更困难的关卡，不断地挑战自己的极限吧！</p>\n<h3 id=\"关于游戏开发\"><a href=\"#关于游戏开发\" class=\"headerlink\" title=\"关于游戏开发\"></a>关于游戏开发</h3><p>本游戏使用 Unity 引擎开发，所有美术素材均由 Pixel Frog 创作，只可用于学习和试玩等非商业性活动。</p>\n<p>开发者名单：</p>\n<p>制作人：yiyaowen</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"游戏下载\"><a href=\"#游戏下载\" class=\"headerlink\" title=\"游戏下载\"></a>游戏下载</h3><p>下载地址：<a href=\"https://github.com/yiyaowen/PirateBomb_SE\">https://github.com/yiyaowen/PirateBomb_SE</a></p>\n<h3 id=\"游戏简介\"><a href=\"#游戏简介\" class=\"headerlink\" title=\"游戏简介\"></a>游戏简介</h3><p><em><strong>畏畏缩缩的船长，会吞炸弹的鲸鱼，还有足球队员光头哥、橄榄球教练水手弟……</strong></em></p>\n<p><em><strong>等等，这个像黄瓜一样的奇怪生物是什么？</strong></em></p>\n<p><img src=\"http://localhost:4000/assets/images/PirateBombSE_Introduction/Main_Menu.jpg\" alt=\"游戏主菜单\"></p>\n<p>在“海盗炸弹特别版”里，玩家将扮演一个能够释放定时炸弹的小海盗，与来自未知地域的奇葩海盗团进行一系列“黑吃黑”的较量。在游戏中，玩家可以移动、跳跃来躲避敌人的攻击，另一方面也可以掐准时机释放炸弹来击败对手，不过偶尔也会有粗心的玩家被自己释放的炸弹击倒。看来，海盗也不是那么好当的呢，一次次地击败对手，进入更困难的关卡，不断地挑战自己的极限吧！</p>\n<h3 id=\"关于游戏开发\"><a href=\"#关于游戏开发\" class=\"headerlink\" title=\"关于游戏开发\"></a>关于游戏开发</h3><p>本游戏使用 Unity 引擎开发，所有美术素材均由 Pixel Frog 创作，只可用于学习和试玩等非商业性活动。</p>\n<p>开发者名单：</p>\n<p>制作人：yiyaowen</p>\n"},{"title":"C++ 中通过构造虚函数表的方式在父类中调用子类重写的虚函数","date":"2020-03-24T16:00:00.000Z","layout":"post","_content":"\n## 问题的起源\n\n在 zhihu 首页看到一个提问：如何在父类中调用子类的虚函数？\n\n看到这个问题，会感到一丝丝疑惑：这难道不是 C++ 本身的特性吗？没错，虚函数就是为此而生的。\n\n比如看下面的代码：\n\n```c++\nclass Base\n{\npublic:\n  virtual void func();\n  void call_child_func();\n}\nclass Child : public Base\n{\npublic:\n  void func() override;\n}\n\nBase::call_child_func()\n{\n  func();\n}\n\nBase* instance = new Child;\ninstance->call_child_func();\n```\n\n这样的调用基本上没什么意义，因为根据虚函数的性质，instance 会按照其本来的类型去调用对应的虚函数，而不是按照表面上表现出来的类型，所以直接用 instance->func() 就可以满足需求。\n\n## 进一步探究\n\nzhihu 上该问题下有一个答案引起了我的兴趣，答主给出了一种通过在子类中构造虚函数表的方式来实现父类调用子类重写的虚函数的方式，虽然其作用和上述方案是一样的，但是构造出的虚函数表结构却很有意思，具体的方法见如下分析：\n\n首先是要用到的头文件和命名空间：\n\n```c++\n#include <iostream>\n#include <functional>\nusing namespace std;\n```\n\n假设现在定义了一个基类为 Monster，这个 Monster 有一个攻击的行为，对应于虚函数 Attack：\n\n```c++\nclass Monster\n{\npublic:\n  virtual void Attack()\n  {   \n    cout << \"Monster Attack!\" << endl;\n  }   \n\n  void InvokeChildAttack()\n  {   \n    // TODO\n  }     \n};\n```\n\n现在的需求是，如何确保当调用 InvokeChildAttack 方法时，调用的是继承了 Monster 的子类中重写的虚函数 Attack，而不是 Monster 中的 Attack。\n\n比如，现在实现一个 Goblin 类继承 Monster，并重写 Attack：\n\n```c++\nclass Goblin : public Monster\n{\npublic:\n  void Attack() override\n  {\n    cout << \"Goblin's stick attack!\" << endl;\n  }\n};\n\n```\n\n接下来是重点，如何在 Monster 中去调用 Goblin 的 Attack 呢？为了使用构造出的虚函数表（等下就会看到），还需在 Monster 中添加几个函数指针成员：\n\n```c++\nclass Monster\n{\npublic:\n  // 省略代码\n\n  void InvokeChildAttack()\n  {   \n    (this->*m_childAttack)();\n  }\n\n  void InvokeChildAttack_cpp11()\n  {   \n    this->m_childAttack_cpp11();\n  }\n\n  void(Monster::*m_childAttack)();\n  function<void()> m_childAttack_cpp11;\n};\n```\n\nm_childAttack 和 m_childAttack_cpp11 将会在子类中被赋值为对应的子类重写的虚函数 Attack，因为这些函数指针变量是在 Monster 中声明的，故在 Monster 中可直接调用它们，这样就达到了在运行时去调用子类的虚函数的目的：\n\n```c++\nclass Goblin : public Monster\n{\npublic:\n  Goblin()\n  {   \n    struct VirtualFuncTable\n    {   \n      union\n      {   \n        void(Goblin::*goblinAttack)();\n        void(Monster::*monsterAttack)();\n      };\n    } m_virtualFuncTable = { &Goblin::Attack };\n    // 通用方法\n    this->m_childAttack = m_virtualFuncTable.monsterAttack;\n    // C++11 中的新方法\n    this->m_childAttack_cpp11 = bind(&Goblin::Attack, this);\n  }\n\n  // 省略代码\n};\n```\n\n如上，在子类 Goblin 的构造函数中，构造了一个虚函数表结构：\n\n```c++\nstruct VirtualFuncTable\n{   \n  union\n  {   \n    void(Goblin::*goblinAttack)();\n    void(Monster::*monsterAttack)();\n  };\n};\n```\n\n其实就是：\n\n```c++\nstruct vbtl\n{\n  union\n  {\n    void(Child_N::*func_N)(); // 继承树中的第 N 代子类\n    // 省略很多代子类\n    void(Child_2::*func_2)(); // 第二代子类\n    void(Child_1::*func_1)(); // 第一代子类\n    void(Parent::*func)(); // 基类\n  };\n};\n```\n\n在虚函数表中，最底层的子类放置在第一个位置，以此类推，最初的父类放置在最后，因为在调用虚函数时，会首先在虚函数表中查找是否有当前类对应的虚函数，如果没有，就尝试查找父类的，如果还没有，就继续查找父类的父类，直到找到第一个重写的虚函数为止，因此会有如上特定的排列顺序。在构造虚函数表时要注意这个顺序不能改变，因为在 C++ 中结构的赋值是一个一个对齐进行的。\n\n```c++\nm_virtualFuncTable = { &Goblin::Attack };\n```\n\n通过这个赋值可以看出，在 C++ 中虚函数和普通的函数不同，声明为 virtual 的函数不再是简单对应一个函数指针，而是对应到一个 union 结构，也就是虚函数表，根据实际类型的不同，这个 union 所对应的函数也不同，这样就实现了虚函数的多态性。\n\n最后执行如下语句：\n\n```c++\nint main()\n{\n  Monster *goblin = new Goblin;\n  goblin->Attack();\n  goblin->InvokeChildAttack();\n  goblin->InvokeChildAttack_cpp11();\n}\n```\n\n输出为：\n\n```\nGoblin's stick attack!\nGoblin's stick attack!\nGoblin's stick attack!\n```\n\n可见，InvokeChildAttack 达到了和单纯的虚函数 Attack 一样的效果。\n\n## 总结\n\n总结来说，这其实映射出 C++ 中虚函数多态的本质，也就是虚函数表的动态性，虽然实际应用中可能价值不大（其实 zhihu 答主给出了一些实际的应用），但是研究一番却很有意思。","source":"_posts/Blogs/2020-3-25-a.md","raw":"---\ntitle: C++ 中通过构造虚函数表的方式在父类中调用子类重写的虚函数\ndate: 2020-3-25\nlayout: post\ntag: C/C++\n---\n\n## 问题的起源\n\n在 zhihu 首页看到一个提问：如何在父类中调用子类的虚函数？\n\n看到这个问题，会感到一丝丝疑惑：这难道不是 C++ 本身的特性吗？没错，虚函数就是为此而生的。\n\n比如看下面的代码：\n\n```c++\nclass Base\n{\npublic:\n  virtual void func();\n  void call_child_func();\n}\nclass Child : public Base\n{\npublic:\n  void func() override;\n}\n\nBase::call_child_func()\n{\n  func();\n}\n\nBase* instance = new Child;\ninstance->call_child_func();\n```\n\n这样的调用基本上没什么意义，因为根据虚函数的性质，instance 会按照其本来的类型去调用对应的虚函数，而不是按照表面上表现出来的类型，所以直接用 instance->func() 就可以满足需求。\n\n## 进一步探究\n\nzhihu 上该问题下有一个答案引起了我的兴趣，答主给出了一种通过在子类中构造虚函数表的方式来实现父类调用子类重写的虚函数的方式，虽然其作用和上述方案是一样的，但是构造出的虚函数表结构却很有意思，具体的方法见如下分析：\n\n首先是要用到的头文件和命名空间：\n\n```c++\n#include <iostream>\n#include <functional>\nusing namespace std;\n```\n\n假设现在定义了一个基类为 Monster，这个 Monster 有一个攻击的行为，对应于虚函数 Attack：\n\n```c++\nclass Monster\n{\npublic:\n  virtual void Attack()\n  {   \n    cout << \"Monster Attack!\" << endl;\n  }   \n\n  void InvokeChildAttack()\n  {   \n    // TODO\n  }     \n};\n```\n\n现在的需求是，如何确保当调用 InvokeChildAttack 方法时，调用的是继承了 Monster 的子类中重写的虚函数 Attack，而不是 Monster 中的 Attack。\n\n比如，现在实现一个 Goblin 类继承 Monster，并重写 Attack：\n\n```c++\nclass Goblin : public Monster\n{\npublic:\n  void Attack() override\n  {\n    cout << \"Goblin's stick attack!\" << endl;\n  }\n};\n\n```\n\n接下来是重点，如何在 Monster 中去调用 Goblin 的 Attack 呢？为了使用构造出的虚函数表（等下就会看到），还需在 Monster 中添加几个函数指针成员：\n\n```c++\nclass Monster\n{\npublic:\n  // 省略代码\n\n  void InvokeChildAttack()\n  {   \n    (this->*m_childAttack)();\n  }\n\n  void InvokeChildAttack_cpp11()\n  {   \n    this->m_childAttack_cpp11();\n  }\n\n  void(Monster::*m_childAttack)();\n  function<void()> m_childAttack_cpp11;\n};\n```\n\nm_childAttack 和 m_childAttack_cpp11 将会在子类中被赋值为对应的子类重写的虚函数 Attack，因为这些函数指针变量是在 Monster 中声明的，故在 Monster 中可直接调用它们，这样就达到了在运行时去调用子类的虚函数的目的：\n\n```c++\nclass Goblin : public Monster\n{\npublic:\n  Goblin()\n  {   \n    struct VirtualFuncTable\n    {   \n      union\n      {   \n        void(Goblin::*goblinAttack)();\n        void(Monster::*monsterAttack)();\n      };\n    } m_virtualFuncTable = { &Goblin::Attack };\n    // 通用方法\n    this->m_childAttack = m_virtualFuncTable.monsterAttack;\n    // C++11 中的新方法\n    this->m_childAttack_cpp11 = bind(&Goblin::Attack, this);\n  }\n\n  // 省略代码\n};\n```\n\n如上，在子类 Goblin 的构造函数中，构造了一个虚函数表结构：\n\n```c++\nstruct VirtualFuncTable\n{   \n  union\n  {   \n    void(Goblin::*goblinAttack)();\n    void(Monster::*monsterAttack)();\n  };\n};\n```\n\n其实就是：\n\n```c++\nstruct vbtl\n{\n  union\n  {\n    void(Child_N::*func_N)(); // 继承树中的第 N 代子类\n    // 省略很多代子类\n    void(Child_2::*func_2)(); // 第二代子类\n    void(Child_1::*func_1)(); // 第一代子类\n    void(Parent::*func)(); // 基类\n  };\n};\n```\n\n在虚函数表中，最底层的子类放置在第一个位置，以此类推，最初的父类放置在最后，因为在调用虚函数时，会首先在虚函数表中查找是否有当前类对应的虚函数，如果没有，就尝试查找父类的，如果还没有，就继续查找父类的父类，直到找到第一个重写的虚函数为止，因此会有如上特定的排列顺序。在构造虚函数表时要注意这个顺序不能改变，因为在 C++ 中结构的赋值是一个一个对齐进行的。\n\n```c++\nm_virtualFuncTable = { &Goblin::Attack };\n```\n\n通过这个赋值可以看出，在 C++ 中虚函数和普通的函数不同，声明为 virtual 的函数不再是简单对应一个函数指针，而是对应到一个 union 结构，也就是虚函数表，根据实际类型的不同，这个 union 所对应的函数也不同，这样就实现了虚函数的多态性。\n\n最后执行如下语句：\n\n```c++\nint main()\n{\n  Monster *goblin = new Goblin;\n  goblin->Attack();\n  goblin->InvokeChildAttack();\n  goblin->InvokeChildAttack_cpp11();\n}\n```\n\n输出为：\n\n```\nGoblin's stick attack!\nGoblin's stick attack!\nGoblin's stick attack!\n```\n\n可见，InvokeChildAttack 达到了和单纯的虚函数 Attack 一样的效果。\n\n## 总结\n\n总结来说，这其实映射出 C++ 中虚函数多态的本质，也就是虚函数表的动态性，虽然实际应用中可能价值不大（其实 zhihu 答主给出了一些实际的应用），但是研究一番却很有意思。","slug":"Blogs/2020-3-25-a","published":1,"updated":"2021-03-25T12:59:59.685Z","_id":"ckmotpi50000br29khmoxclc6","comments":1,"photos":[],"link":"","content":"<h2 id=\"问题的起源\"><a href=\"#问题的起源\" class=\"headerlink\" title=\"问题的起源\"></a>问题的起源</h2><p>在 zhihu 首页看到一个提问：如何在父类中调用子类的虚函数？</p>\n<p>看到这个问题，会感到一丝丝疑惑：这难道不是 C++ 本身的特性吗？没错，虚函数就是为此而生的。</p>\n<p>比如看下面的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">call_child_func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> :</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Base::<span class=\"built_in\">call_child_func</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">func</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Base* instance = <span class=\"keyword\">new</span> Child;</span><br><span class=\"line\">instance-&gt;<span class=\"built_in\">call_child_func</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这样的调用基本上没什么意义，因为根据虚函数的性质，instance 会按照其本来的类型去调用对应的虚函数，而不是按照表面上表现出来的类型，所以直接用 instance-&gt;func() 就可以满足需求。</p>\n<h2 id=\"进一步探究\"><a href=\"#进一步探究\" class=\"headerlink\" title=\"进一步探究\"></a>进一步探究</h2><p>zhihu 上该问题下有一个答案引起了我的兴趣，答主给出了一种通过在子类中构造虚函数表的方式来实现父类调用子类重写的虚函数的方式，虽然其作用和上述方案是一样的，但是构造出的虚函数表结构却很有意思，具体的方法见如下分析：</p>\n<p>首先是要用到的头文件和命名空间：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br></pre></td></tr></table></figure>\n\n<p>假设现在定义了一个基类为 Monster，这个 Monster 有一个攻击的行为，对应于虚函数 Attack：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Monster</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;   </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Monster Attack!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InvokeChildAttack</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">// TODO</span></span><br><span class=\"line\">  &#125;     </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>现在的需求是，如何确保当调用 InvokeChildAttack 方法时，调用的是继承了 Monster 的子类中重写的虚函数 Attack，而不是 Monster 中的 Attack。</p>\n<p>比如，现在实现一个 Goblin 类继承 Monster，并重写 Attack：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goblin</span> :</span> <span class=\"keyword\">public</span> Monster</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Goblin&#x27;s stick attack!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>接下来是重点，如何在 Monster 中去调用 Goblin 的 Attack 呢？为了使用构造出的虚函数表（等下就会看到），还需在 Monster 中添加几个函数指针成员：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Monster</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InvokeChildAttack</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;   </span><br><span class=\"line\">    (<span class=\"keyword\">this</span>-&gt;*m_childAttack)();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InvokeChildAttack_cpp11</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">m_childAttack_cpp11</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Monster::*m_childAttack)();</span><br><span class=\"line\">  function&lt;<span class=\"built_in\"><span class=\"keyword\">void</span></span>()&gt; m_childAttack_cpp11;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>m_childAttack 和 m_childAttack_cpp11 将会在子类中被赋值为对应的子类重写的虚函数 Attack，因为这些函数指针变量是在 Monster 中声明的，故在 Monster 中可直接调用它们，这样就达到了在运行时去调用子类的虚函数的目的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goblin</span> :</span> <span class=\"keyword\">public</span> Monster</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">Goblin</span>()</span><br><span class=\"line\">  &#123;   </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VirtualFuncTable</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span>   </span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">      &#123;</span>   </span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Goblin::*goblinAttack)();</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Monster::*monsterAttack)();</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125; m_virtualFuncTable = &#123; &amp;Goblin::Attack &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 通用方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;m_childAttack = m_virtualFuncTable.monsterAttack;</span><br><span class=\"line\">    <span class=\"comment\">// C++11 中的新方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;m_childAttack_cpp11 = <span class=\"built_in\">bind</span>(&amp;Goblin::Attack, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如上，在子类 Goblin 的构造函数中，构造了一个虚函数表结构：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VirtualFuncTable</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span>   </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">  &#123;</span>   </span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Goblin::*goblinAttack)();</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Monster::*monsterAttack)();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其实就是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vbtl</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">  &#123;</span></span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Child_N::*func_N)(); <span class=\"comment\">// 继承树中的第 N 代子类</span></span><br><span class=\"line\">    <span class=\"comment\">// 省略很多代子类</span></span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Child_2::*func_2)(); <span class=\"comment\">// 第二代子类</span></span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Child_1::*func_1)(); <span class=\"comment\">// 第一代子类</span></span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Parent::*func)(); <span class=\"comment\">// 基类</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在虚函数表中，最底层的子类放置在第一个位置，以此类推，最初的父类放置在最后，因为在调用虚函数时，会首先在虚函数表中查找是否有当前类对应的虚函数，如果没有，就尝试查找父类的，如果还没有，就继续查找父类的父类，直到找到第一个重写的虚函数为止，因此会有如上特定的排列顺序。在构造虚函数表时要注意这个顺序不能改变，因为在 C++ 中结构的赋值是一个一个对齐进行的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m_virtualFuncTable = &#123; &amp;Goblin::Attack &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>通过这个赋值可以看出，在 C++ 中虚函数和普通的函数不同，声明为 virtual 的函数不再是简单对应一个函数指针，而是对应到一个 union 结构，也就是虚函数表，根据实际类型的不同，这个 union 所对应的函数也不同，这样就实现了虚函数的多态性。</p>\n<p>最后执行如下语句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  Monster *goblin = <span class=\"keyword\">new</span> Goblin;</span><br><span class=\"line\">  goblin-&gt;<span class=\"built_in\">Attack</span>();</span><br><span class=\"line\">  goblin-&gt;<span class=\"built_in\">InvokeChildAttack</span>();</span><br><span class=\"line\">  goblin-&gt;<span class=\"built_in\">InvokeChildAttack_cpp11</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Goblin&#39;s stick attack!</span><br><span class=\"line\">Goblin&#39;s stick attack!</span><br><span class=\"line\">Goblin&#39;s stick attack!</span><br></pre></td></tr></table></figure>\n\n<p>可见，InvokeChildAttack 达到了和单纯的虚函数 Attack 一样的效果。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结来说，这其实映射出 C++ 中虚函数多态的本质，也就是虚函数表的动态性，虽然实际应用中可能价值不大（其实 zhihu 答主给出了一些实际的应用），但是研究一番却很有意思。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题的起源\"><a href=\"#问题的起源\" class=\"headerlink\" title=\"问题的起源\"></a>问题的起源</h2><p>在 zhihu 首页看到一个提问：如何在父类中调用子类的虚函数？</p>\n<p>看到这个问题，会感到一丝丝疑惑：这难道不是 C++ 本身的特性吗？没错，虚函数就是为此而生的。</p>\n<p>比如看下面的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">call_child_func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> :</span> <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Base::<span class=\"built_in\">call_child_func</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">func</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Base* instance = <span class=\"keyword\">new</span> Child;</span><br><span class=\"line\">instance-&gt;<span class=\"built_in\">call_child_func</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这样的调用基本上没什么意义，因为根据虚函数的性质，instance 会按照其本来的类型去调用对应的虚函数，而不是按照表面上表现出来的类型，所以直接用 instance-&gt;func() 就可以满足需求。</p>\n<h2 id=\"进一步探究\"><a href=\"#进一步探究\" class=\"headerlink\" title=\"进一步探究\"></a>进一步探究</h2><p>zhihu 上该问题下有一个答案引起了我的兴趣，答主给出了一种通过在子类中构造虚函数表的方式来实现父类调用子类重写的虚函数的方式，虽然其作用和上述方案是一样的，但是构造出的虚函数表结构却很有意思，具体的方法见如下分析：</p>\n<p>首先是要用到的头文件和命名空间：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br></pre></td></tr></table></figure>\n\n<p>假设现在定义了一个基类为 Monster，这个 Monster 有一个攻击的行为，对应于虚函数 Attack：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Monster</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;   </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Monster Attack!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InvokeChildAttack</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;   </span><br><span class=\"line\">    <span class=\"comment\">// TODO</span></span><br><span class=\"line\">  &#125;     </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>现在的需求是，如何确保当调用 InvokeChildAttack 方法时，调用的是继承了 Monster 的子类中重写的虚函数 Attack，而不是 Monster 中的 Attack。</p>\n<p>比如，现在实现一个 Goblin 类继承 Monster，并重写 Attack：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goblin</span> :</span> <span class=\"keyword\">public</span> Monster</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Attack</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Goblin&#x27;s stick attack!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>接下来是重点，如何在 Monster 中去调用 Goblin 的 Attack 呢？为了使用构造出的虚函数表（等下就会看到），还需在 Monster 中添加几个函数指针成员：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Monster</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InvokeChildAttack</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;   </span><br><span class=\"line\">    (<span class=\"keyword\">this</span>-&gt;*m_childAttack)();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InvokeChildAttack_cpp11</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">m_childAttack_cpp11</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Monster::*m_childAttack)();</span><br><span class=\"line\">  function&lt;<span class=\"built_in\"><span class=\"keyword\">void</span></span>()&gt; m_childAttack_cpp11;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>m_childAttack 和 m_childAttack_cpp11 将会在子类中被赋值为对应的子类重写的虚函数 Attack，因为这些函数指针变量是在 Monster 中声明的，故在 Monster 中可直接调用它们，这样就达到了在运行时去调用子类的虚函数的目的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goblin</span> :</span> <span class=\"keyword\">public</span> Monster</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">Goblin</span>()</span><br><span class=\"line\">  &#123;   </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VirtualFuncTable</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span>   </span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">      &#123;</span>   </span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Goblin::*goblinAttack)();</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Monster::*monsterAttack)();</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125; m_virtualFuncTable = &#123; &amp;Goblin::Attack &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 通用方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;m_childAttack = m_virtualFuncTable.monsterAttack;</span><br><span class=\"line\">    <span class=\"comment\">// C++11 中的新方法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;m_childAttack_cpp11 = <span class=\"built_in\">bind</span>(&amp;Goblin::Attack, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如上，在子类 Goblin 的构造函数中，构造了一个虚函数表结构：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VirtualFuncTable</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span>   </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">  &#123;</span>   </span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Goblin::*goblinAttack)();</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Monster::*monsterAttack)();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其实就是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vbtl</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">  &#123;</span></span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Child_N::*func_N)(); <span class=\"comment\">// 继承树中的第 N 代子类</span></span><br><span class=\"line\">    <span class=\"comment\">// 省略很多代子类</span></span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Child_2::*func_2)(); <span class=\"comment\">// 第二代子类</span></span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Child_1::*func_1)(); <span class=\"comment\">// 第一代子类</span></span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span>(Parent::*func)(); <span class=\"comment\">// 基类</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在虚函数表中，最底层的子类放置在第一个位置，以此类推，最初的父类放置在最后，因为在调用虚函数时，会首先在虚函数表中查找是否有当前类对应的虚函数，如果没有，就尝试查找父类的，如果还没有，就继续查找父类的父类，直到找到第一个重写的虚函数为止，因此会有如上特定的排列顺序。在构造虚函数表时要注意这个顺序不能改变，因为在 C++ 中结构的赋值是一个一个对齐进行的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m_virtualFuncTable = &#123; &amp;Goblin::Attack &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>通过这个赋值可以看出，在 C++ 中虚函数和普通的函数不同，声明为 virtual 的函数不再是简单对应一个函数指针，而是对应到一个 union 结构，也就是虚函数表，根据实际类型的不同，这个 union 所对应的函数也不同，这样就实现了虚函数的多态性。</p>\n<p>最后执行如下语句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  Monster *goblin = <span class=\"keyword\">new</span> Goblin;</span><br><span class=\"line\">  goblin-&gt;<span class=\"built_in\">Attack</span>();</span><br><span class=\"line\">  goblin-&gt;<span class=\"built_in\">InvokeChildAttack</span>();</span><br><span class=\"line\">  goblin-&gt;<span class=\"built_in\">InvokeChildAttack_cpp11</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Goblin&#39;s stick attack!</span><br><span class=\"line\">Goblin&#39;s stick attack!</span><br><span class=\"line\">Goblin&#39;s stick attack!</span><br></pre></td></tr></table></figure>\n\n<p>可见，InvokeChildAttack 达到了和单纯的虚函数 Attack 一样的效果。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结来说，这其实映射出 C++ 中虚函数多态的本质，也就是虚函数表的动态性，虽然实际应用中可能价值不大（其实 zhihu 答主给出了一些实际的应用），但是研究一番却很有意思。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckmotoivd0008r29k7i3w93be","tag_id":"ckmnkf29n0002sh9k3cda8ajz","_id":"ckmotoive0009r29k91i6gf3m"},{"post_id":"ckmotpi50000br29khmoxclc6","tag_id":"ckmots2f2000cr29kfha7dfsp","_id":"ckmots2f2000dr29kdo3ac0x5"}],"Tag":[{"name":"游戏","_id":"ckmnkf29n0002sh9k3cda8ajz"},{"name":"C/C++","_id":"ckmots2f2000cr29kfha7dfsp"}]}}